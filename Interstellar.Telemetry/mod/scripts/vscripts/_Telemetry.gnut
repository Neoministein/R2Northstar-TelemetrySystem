untyped

global function Telemetry_Init

global const WS_NAME = "Telemetry"

global const NO_MATCH = "NO_MATCH"

global const NO_BODY = "NO_BODY"

global const UNKNOWN = "UNKNOWN"

struct {
    //GameInfo
    string northstarVersion,
    string modVersion,

    //Configuration
    string hostname,
    string apiKey,
    bool tls,

    float timeBetweenState,
    float ignoreEventsAfterDelay,

    bool recordNpcs,

    //Internal values
    bool isClientCompatible = false,

    string matchId = NO_MATCH,

    table matchState,
    table players,
} file

//onTitanDoomedCallbacks
//onPlayerAssistCallbacks
//onEntityChangedTeamCallbacks

//AddOnRodeoStartedCallback
//AddOnRodeoEndedCallback

void function Telemetry_Init()
{
    file.northstarVersion = NSGetModVersionByModName("Northstar.Client")
    file.modVersion = NSGetModVersionByModName("Interstellar.Telemetry")

    file.hostname = GetConVarString( "ts-hostname" )
    file.apiKey = GetConVarString( "ts-apiKey" )
    file.tls = GetConVarBool( "ts-tls" )
    file.timeBetweenState = GetConVarFloat( "ts-timeBetweenState" )

    file.ignoreEventsAfterDelay = GetConVarFloat( "ts-ignoreEventsAfterDelay" )
    file.recordNpcs = GetConVarBool( "ts-recordNpcs" )

    file.matchState["map"] <- GetMapName()
    file.matchState["players"] <- []
    file.matchState["npcs"] <- []

    table events

    events["playerConnect"] <- []
    events["playerDisconnect"] <- []
    events["entityKilled"] <- []
    events["playerRespawned"] <- []
    events["pilotBecomesTitan"] <- []
    events["titanBecomesPilot"] <- []
    events["playerJump"] <- []
    events["playerDoubleJump"] <- []
    events["playerMantle"] <- []
    events["npcLeeched"] <- []

    file.matchState["events"] <- events

    CheckForClientCompatibility()

    AddCallback_GameStateEnter( eGameState.WaitingForPlayers, RegisterNewMatch )
    AddCallback_GameStateEnter( eGameState.Playing, OnMatchStart )
    AddCallback_GameStateEnter( eGameState.Postmatch, OnGameFinished )

    AddCallback_OnClientConnected( Map_PlayerConnect )
    AddCallback_OnClientDisconnected( Map_PlayerDisconnect )

    AddCallback_OnPilotBecomesTitan( Map_PilotBecomesTitan )
    AddCallback_OnTitanBecomesPilot( Map_TitanBecomesPilot )

    AddCallback_OnPlayerKilled( Map_EntityKilled )
    AddCallback_OnNPCKilled( Map_EntityKilled )

    AddCallback_NPCLeeched( Map_OnSpectreLeeched )

    AddCallback_OnPlayerRespawned( Map_PlayerRespawned )

    AddCallback_OnPlayerGetsNewPilotLoadout( Map_OnPlayerGetsNewPilotLoadout )
}

void function SendHttpToBackend(string path, int method, string body, void functionref( HttpRequestResponse ) onSuccess = null, void functionref( HttpRequestFailure ) onFailure = null)
{
    HttpRequest request = { ... }
    request.method = method
    request.url =  file.tls ? "https://" : "http://" + file.hostname + path

    if(body != NO_BODY) {
        request.body = body
    }

	request.headers["User-Agent"] <- []
    request.headers["User-Agent"].append("R2Northstar/" + file.northstarVersion)
    request.headers["User-Agent"].append("Interstellar.Telemetry/" + file.modVersion)
    request.headers["Authorization"] <- []
    request.headers["Authorization"].append("BEARER " + file.apiKey)

    NSHttpRequest(request, onSuccess, onFailure)
}

void function GenericHttpFailure(HttpRequestFailure faluire )
{
    file.isClientCompatible = false
    file.matchId = NO_MATCH

    wait file.timeBetweenState + 0.1

    NS_DisconnectFromWebsocket(WS_NAME)
}

void function GenericHttpSuccess( HttpRequestResponse response )
{

}

void function CheckForClientCompatibility()
{
    SendHttpToBackend("/api/client/compatibility/" + file.modVersion , HttpRequestMethod.GET, NO_BODY ,CheckForClientCompatibility_Success, GenericHttpFailure)
}

void function CheckForClientCompatibility_Success(HttpRequestResponse response )
{
    file.isClientCompatible = expect bool (DecodeJSON(response.body)["compatible"])
}

void function RegisterNewMatch()
{
    table body
    body["nsServerName"] <- GetConVarString( "ns_server_name" )
    body["maxPlayers"] <- GetCurrentPlaylistVarInt( "max_players", 8 )
    body["map"] <- GetMapName()
    body["gamemode"] <- GameRules_GetGameMode()

    SendHttpToBackend("/api/v1/match/new", HttpRequestMethod.POST, EncodeJSON(body),RegisterNewMatch_Success, GenericHttpFailure)
}

void function RegisterNewMatch_Success(HttpRequestResponse response )
{
    file.matchId = expect string (DecodeJSON(response.body)["id"])
    file.matchState["matchId"] <- file.matchId

    string url = file.tls ? "wss://" : "ws://" + file.hostname + "/ws/state/input"
    table<string , string > headers
    headers["Authorization"] <- "BEARER " + file.apiKey

    NS_ConnectToWebsocket(WS_NAME, url , WebsocketPool, 60, headers)
}

void function WebsocketPool(string data) {}

void function OnMatchStart()
{
    if ( file.matchId != NO_MATCH ) {
        thread MainTelemetryLoop()
    }
}

void function MainTelemetryLoop()
{
	while ( file.matchId != NO_MATCH )
	{

        array<entity> players = GetPlayerArray()
		foreach(entity player in GetPlayerArray())
		{

		   	if(player.GetUID() in file.players ) {
                table playerTable = expect table( file.players[player.GetUID()] )
		   	    playerTable["health"] <- (100.0 * player.GetHealth() / player.GetMaxHealth())
		   	    VectorToTable( expect table( playerTable["position"] ),  player.GetOrigin() )
		   	    VectorToTable( expect table( playerTable["rotation"] ),  player.GetAngles() )
		   	    VectorToTable( expect table( playerTable["velocity"] ),  player.GetVelocity() )

		   	} else {
		   	    print("Player " + player.GetUID() + " does not exist in the telemetry system")
		   	}
		}

		file.matchState["players"] <- TableValuesToArray( file.players )
        file.matchState["timePassed"] <- (Time() * 1000).tointeger()

		NS_WriteToWebsocket(WS_NAME, EncodeJSON(file.matchState))

        table events = expect table( file.matchState["events"] )
		events["playerConnect"].clear()
        events["playerDisconnect"].clear()
        events["entityKilled"].clear()
        events["playerRespawned"].clear()
        events["pilotBecomesTitan"].clear()
        events["titanBecomesPilot"].clear()
        events["playerJump"].clear()
        events["playerDoubleJump"].clear()
        events["playerMantle"].clear()
        events["npcLeeched"].clear()

		wait file.timeBetweenState
	}
}

void function OnGameFinished()
{
    SendHttpToBackend("/api/v1/match/end/" + file.matchId, HttpRequestMethod.POST, NO_BODY , GenericHttpSuccess, GenericHttpFailure)

    file.matchId = NO_MATCH

    wait file.timeBetweenState + 0.1

    NS_DisconnectFromWebsocket(WS_NAME)
}

void function Map_PlayerConnect( entity player )
{
	table playerTable
	playerTable["entityId"] <- player.GetPlayerName()
	playerTable["team"] <- player.GetTeam()
	playerTable["titanClass"] <- UNKNOWN
	playerTable["isTitan"] <- false
	playerTable["isWallRunning"] <- false
	playerTable["isShooting"] <- false
	playerTable["isGrounded"] <- false
	playerTable["isHanging"] <- false
	playerTable["isCrouching"] <- false
	playerTable["isAlive"] <- true

	playerTable["position"] <- {}
	playerTable["rotation"] <- {}
	playerTable["velocity"] <- {}
	playerTable["equipment"] <- {}

	file.players[player.GetUID()] <- playerTable

    AddPlayerMovementEventCallback( player, ePlayerMovementEvents.BEGIN_WALLRUN, Map_OnPlayerBeginWallrun )
    AddPlayerMovementEventCallback( player, ePlayerMovementEvents.END_WALLRUN, Map_OnPlayerEndWallrun )

    AddPlayerMovementEventCallback( player, ePlayerMovementEvents.JUMP, Map_OnPlayerJump )
    AddPlayerMovementEventCallback( player, ePlayerMovementEvents.DOUBLE_JUMP, Map_OnPlayerDoubleJump )

    AddPlayerMovementEventCallback( player, ePlayerMovementEvents.LEAVE_GROUND, Map_OnPlayerLeaveGround )
    AddPlayerMovementEventCallback( player, ePlayerMovementEvents.TOUCH_GROUND, Map_OnPlayerTochGround )

    AddPlayerMovementEventCallback( player, ePlayerMovementEvents.MANTLE, Map_OnPlayerMantle )

    AddPlayerMovementEventCallback( player, ePlayerMovementEvents.BEGIN_WALLHANG, Map_OnPlayerBeginWallHang )
    AddPlayerMovementEventCallback( player, ePlayerMovementEvents.END_WALLHANG, Map_OnPlayerEndWallHang )


    AddButtonPressedPlayerInputCallback( player, 1, Map_StartShoot)
    AddButtonReleasedPlayerInputCallback( player, 1, Map_EndShoot)

    AddButtonPressedPlayerInputCallback( player, 4, Map_OnPlayerBeginCrouch)
    AddButtonReleasedPlayerInputCallback( player, 4, Map_OnPlayerEndCrouch)
}

void function Map_PlayerDisconnect( entity player )
{
	file.players[player.GetUID()] <- {}

    RemovePlayerMovementEventCallback( player, ePlayerMovementEvents.BEGIN_WALLRUN, Map_OnPlayerBeginWallrun )
    RemovePlayerMovementEventCallback( player, ePlayerMovementEvents.END_WALLRUN, Map_OnPlayerEndWallrun )

    RemovePlayerMovementEventCallback( player, ePlayerMovementEvents.JUMP, Map_OnPlayerJump )
    RemovePlayerMovementEventCallback( player, ePlayerMovementEvents.DOUBLE_JUMP, Map_OnPlayerDoubleJump )

    RemovePlayerMovementEventCallback( player, ePlayerMovementEvents.LEAVE_GROUND, Map_OnPlayerLeaveGround )
    RemovePlayerMovementEventCallback( player, ePlayerMovementEvents.TOUCH_GROUND, Map_OnPlayerTochGround )

    RemovePlayerMovementEventCallback( player, ePlayerMovementEvents.MANTLE, Map_OnPlayerMantle )

    RemovePlayerMovementEventCallback( player, ePlayerMovementEvents.BEGIN_WALLHANG, Map_OnPlayerBeginWallHang )
    RemovePlayerMovementEventCallback( player, ePlayerMovementEvents.END_WALLHANG, Map_OnPlayerEndWallHang )

    RemoveButtonPressedPlayerInputCallback( player, 1, Map_StartShoot)
    RemoveButtonPressedPlayerInputCallback( player, 1, Map_EndShoot)
}

void function GetNpcData()
{
    /*
    string entityInfo = ""
    int numberOfEntities = 0;
    array<entity> npc = GetNPCArrayByClass( "npc_soldier" )

    numberOfEntities += npc.len()
    entityInfo += GetNpcClassDataWithWeapon( npc, "npc_soldier" )

    npc = GetNPCArrayByClass( "npc_spectre" )
    numberOfEntities += npc.len()
    entityInfo += GetNpcClassDataWithWeapon( npc, "npc_spectre" )

    npc = GetNPCArrayByClass( "npc_stalker" )
    numberOfEntities += npc.len()
    entityInfo += GetNpcClassDataWithWeapon( npc, "npc_stalker" )
    NSSendToNamedPipe("31|" + numberOfEntities + entityInfo)


    entityInfo = ""
    numberOfEntities = 0;
    npc = GetNPCArrayByClass( "npc_super_spectre" )
    numberOfEntities += npc.len()
    entityInfo += GetNpcClassData( npc, "npc_super_spectre" )

    npc = GetNPCArrayByClass( "npc_drone" )
    numberOfEntities += npc.len()
    entityInfo += GetNpcClassData( npc, "npc_drone" )

    npc = GetNPCArrayByClass( "npc_dropship" )
    numberOfEntities += npc.len()
    entityInfo += GetNpcClassData( npc, "npc_dropship" )

    npc = GetNPCArrayByClass( "npc_turret_sentry" )
    numberOfEntities += npc.len()
    entityInfo += GetNpcClassData( npc, "npc_turret_sentry" )

    npc = GetNPCArrayByClass( "npc_turret_mega" )
    numberOfEntities += npc.len()
    entityInfo += GetNpcClassData( npc, "npc_turret_mega" )
    NSSendToNamedPipe("30|" + numberOfEntities + entityInfo)


    entityInfo = ""
    numberOfEntities = 0;
    npc = GetNPCArrayByClass( "npc_titan" )
    numberOfEntities += npc.len()
    entityInfo += GetNpcTitanClassData( npc, "npc_titan" )

    NSSendToNamedPipe("32|" + numberOfEntities + entityInfo)
    */
}

string function GetNpcClassData(array< entity > entities, string npcClass)
{
    /*
    string info = ""
	foreach ( ent in entities )
	{
        info += "|" + npcClass
        info += "|" + ent.GetEncodedEHandle()
        info += "|" + ent.GetTeam()
        info += "|" + ent.GetOrigin()
        info += "|" + ent.GetAngles()
        info += "|" + ent.GetVelocity()
        info += "|" + (100.0 * ent.GetHealth() / ent.GetMaxHealth())
    }
    return info;
    */
    return "";
}

string function GetNpcClassDataWithWeapon(array< entity > entities, string npcClass)
{
    /*
    string info = ""
	foreach ( ent in entities )
	{
        info += "|" + npcClass
        info += "|" + ent.GetEncodedEHandle()
        info += "|" + ent.GetTeam()
        info += "|" + ent.GetOrigin()
        info += "|" + ent.GetAngles()
        info += "|" + ent.GetVelocity()
        info += "|" + (100.0 * ent.GetHealth() / ent.GetMaxHealth())
        if (ent.GetMainWeapons().len() == 1)
        {
            info += "|" + ent.GetMainWeapons()[0] + "|-"
        }
        else if (ent.GetMainWeapons().len() == 2)
        {
            info += "|" + ent.GetMainWeapons()[0] + "|" + ent.GetMainWeapons()[1]
        } else {
            info += "|-|-"
        }
    }
    return info;
    */
    return "";
}

string function GetNpcTitanClassData(array< entity > entities, string npcClass)
{
    /*
    string info = ""
	foreach ( ent in entities )
	{
        info += "|" + npcClass
        info += "|" + ent.GetEncodedEHandle()
        info += "|" + ent.GetTeam()
        info += "|" + ent.GetOrigin()
        info += "|" + ent.GetAngles()
        info += "|" + ent.GetVelocity()
        info += "|" + (100.0 * ent.GetHealth() / ent.GetMaxHealth())
        info += "|" + GetSoulTitanSubClass( ent.GetTitanSoul() )
    }
    return info;
    */
    return "";
}

void function Map_OnSpectreLeeched( entity spectre, entity player )
{
    table leachEvent = { playerId = player.GetUID(), npcId = spectre.GetEncodedEHandle()}


    file.matchState["events"]["npcLeeched"].append(leachEvent)
}

void function Map_EntityKilled( entity victim, entity attacker, var damageInfo )
{
    table killEvent

    killEvent["damageType"] <- DamageInfo_GetDamageWeaponName( damageInfo )

    if (attacker.IsPlayer()) {
        killEvent["isAttackerPlayer"] <- true
        killEvent["attackerId"] <- attacker.GetUID()
    } else {
        killEvent["isAttackerPlayer"] <- false
        try
        {
            killEvent["attackerId"] <- attacker.GetEncodedEHandle()
        } catch (exception) {
            killEvent["attackerId"] <- UNKNOWN
        }
    }

    if (victim.IsPlayer()) {
        killEvent["isVictimPlayer"] <- true
        killEvent["victimId"] <- victim.GetUID()
        file.players[victim.GetUID()]["isAlive"] <- false
        file.players[victim.GetUID()]["isTitan"] <- false
        file.players[victim.GetUID()]["titanClass"] <- UNKNOWN
    }
    else
    {
        killEvent["isVictimPlayer"] <- false
        try {
            killEvent["victimId"] <- attacker.GetEncodedEHandle()
        } catch (exception) {
            killEvent["victimId"] <- UNKNOWN
        }
    }
    file.matchState["events"]["entityKilled"].append(killEvent)
}

void function Map_PlayerRespawned( entity player )
{
    table playerRespawned = { entityId = player.GetUID() }

    file.matchState["events"]["playerRespawned"].append(playerRespawned)
    file.players[player.GetUID()]["isAlive"] <- true

}

void function Map_PilotBecomesTitan( entity player, entity titan )
{
	table pilotBecomesTitan = { entityId = player.GetUID(), titanClass = GetActiveTitanLoadout( player ).titanClass }
    file.matchState["events"]["pilotBecomesTitan"].append(pilotBecomesTitan)
    file.players[player.GetUID()]["isTitan"] <- true
}

void function Map_TitanBecomesPilot( entity player, entity titan )
{
    table titanBecomesTitan = { entityId = player.GetUID() }

    file.matchState["events"]["titanBecomesPilot"].append(titanBecomesTitan)
    file.players[player.GetUID()]["isTitan"] <- false
    file.players[player.GetUID()]["titanClass"] <- UNKNOWN
}

void function Map_OnPlayerGetsNewPilotLoadout( entity player, PilotLoadoutDef newPilotLoadout )
{
    table playerLoadout = expect table( file.players[player.GetUID()]["equipment"] )
    playerLoadout["primary"] <- newPilotLoadout.primary
    playerLoadout["secondary"] <- newPilotLoadout.secondary
    playerLoadout["weapon3"] <- newPilotLoadout.weapon3
    playerLoadout["special"] <- newPilotLoadout.special
}

void function Map_OnPlayerBeginWallrun( entity player )
{
    file.players[player.GetUID()]["isWallRunning"] <- true
}

void function Map_OnPlayerEndWallrun( entity player )
{
    file.players[player.GetUID()]["isWallRunning"] <- false
}

void function Map_StartShoot( entity player )
{
    file.players[player.GetUID()]["isShooting"] <- true
}

void function Map_EndShoot( entity player )
{
    file.players[player.GetUID()]["isShooting"] <- false
}

void function Map_OnPlayerJump( entity player )
{
    table playerJump = { entityId = player.GetUID() }

    file.matchState["events"]["playerJump"].append(playerJump)
}

void function Map_OnPlayerDoubleJump( entity player )
{
    table playerJump = { entityId = player.GetUID() }

    file.matchState["events"]["playerDoubleJump"].append(playerJump)
}

void function Map_OnPlayerLeaveGround( entity player )
{
    file.players[player.GetUID()]["isGrounded"] <- false
}

void function Map_OnPlayerTochGround( entity player )
{
    file.players[player.GetUID()]["isGrounded"] <- true
}

void function Map_OnPlayerMantle( entity player )
{
    table mantle = { entityId = player.GetUID() }

    file.matchState["events"]["playerJump"].append(mantle)
}

void function Map_OnPlayerBeginWallHang( entity player )
{
    file.players[player.GetUID()]["isHanging"] <- true
}

void function Map_OnPlayerEndWallHang( entity player )
{
    file.players[player.GetUID()]["isHanging"] <- false
}

void function Map_OnPlayerBeginCrouch( entity player )
{
    file.players[player.GetUID()]["isCrouching"] <- false
}

void function Map_OnPlayerEndCrouch( entity player )
{
    file.players[player.GetUID()]["isCrouching"] <- false
}

function TableValuesToArray( tab )
{
	Assert( type( tab ) == "table", "Not a table" )

	local resultArray = []
	resultArray.resize( tab.len() )
	int currentArrayIndex = 0
	foreach ( key, val in tab )
	{
		resultArray[ currentArrayIndex ] = val
		++currentArrayIndex
	}

	return resultArray
}

void function VectorToTable(table t, vector vec)
{
    t.rawset("x", (vec.x).tointeger())
    t.rawset("y", (vec.y).tointeger())
    t.rawset("z", (vec.z).tointeger())
}