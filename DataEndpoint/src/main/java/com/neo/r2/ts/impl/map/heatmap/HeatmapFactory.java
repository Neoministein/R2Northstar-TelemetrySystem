package com.neo.r2.ts.impl.map.heatmap;

import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.neo.r2.ts.impl.map.scaling.GameMap;
import com.neo.r2.ts.impl.map.scaling.MapScale;
import com.neo.r2.ts.persistence.entity.Heatmap;
import com.neo.r2.ts.persistence.entity.HeatmapType;
import com.neo.r2.ts.persistence.searchable.MatchEvent;
import com.neo.r2.ts.persistence.searchable.MatchEventSearchable;
import com.neo.r2.ts.impl.rest.CustomConstants;
import com.neo.util.common.impl.exception.ConfigurationException;
import com.neo.util.common.impl.exception.ExceptionDetails;
import com.neo.util.common.impl.exception.ValidationException;
import com.neo.util.common.impl.json.JsonUtil;
import com.neo.util.framework.api.persistence.aggregation.*;
import com.neo.util.framework.api.persistence.criteria.ExplicitSearchCriteria;
import com.neo.util.framework.api.persistence.criteria.LongRangeSearchCriteria;
import com.neo.util.framework.api.persistence.criteria.SearchCriteria;
import com.neo.util.framework.api.persistence.search.SearchQuery;
import com.neo.util.framework.api.persistence.search.SearchProvider;
import com.neo.util.framework.api.persistence.search.SearchResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;

import java.util.*;

@ApplicationScoped
public class HeatmapFactory {

    private static final Logger LOGGER = LoggerFactory.getLogger(HeatmapFactory.class);

    protected static final String COUNT = "count";
    protected static final String PLAYER_POS_X = "entity.position.x";
    protected static final String PLAYER_POS_Y = "entity.position.y";

    protected static final int PIXELS_PER_CALL = 4;

    protected static final ExceptionDetails EX_UNSUPPORTED_HEATMAP = new ExceptionDetails(
            "r2ts/map/heatmap/unsupported-type", "Unsupported heatmap type {0}", false
    );

    protected static final SimpleFieldAggregation COUNT_AGGREGATION = new SimpleFieldAggregation(COUNT, MatchEventSearchable.F_MATCH_ID, SimpleFieldAggregation.Type.COUNT);

    @Inject
    protected SearchProvider searchProvider;

    public Heatmap createForMap(GameMap gameMap) {
        Heatmap heatmap = generateHeatmap(
                gameMap.scale(),
                List.of(
                        new ExplicitSearchCriteria("map", gameMap.name()),
                        new ExplicitSearchCriteria("eventType", MatchEvent.PLAYER_POSITION.fieldName)),
                PIXELS_PER_CALL
        );

        heatmap.setMap(gameMap.name());
        heatmap.setType(HeatmapType.FULL_MAP_AGGREGATION.toString());
        heatmap.setDescription("This is an autogenerated heatmap for the map " + gameMap.name());

        return heatmap;
    }

    public Heatmap createForMatch(String matchId, GameMap gameMap, HeatmapType heatmapType) {
        List<SearchCriteria> searchCriteriaList = new ArrayList<>();
        switch (heatmapType) {
            case PLAYER_POSITION:
                searchCriteriaList.add(new ExplicitSearchCriteria(MatchEventSearchable.F_MATCH_ID, matchId));
                searchCriteriaList.add(new ExplicitSearchCriteria("eventType", MatchEvent.PLAYER_POSITION.fieldName));
                break;
            case FULL_MAP_AGGREGATION:
            case CUSTOM:
            default:
                throw new ValidationException(EX_UNSUPPORTED_HEATMAP, heatmapType);
        }

        Heatmap heatmap = generateHeatmap(gameMap.scale(), searchCriteriaList, PIXELS_PER_CALL);
        heatmap.setMap(gameMap.name());
        heatmap.setType(heatmapType.toString());
        heatmap.setDescription("This is an autogenerated heatmap for the match " + matchId);
        return heatmap;
    }

    protected Heatmap generateHeatmap(MapScale mapScale, List<SearchCriteria> basicCriteria, int resolution) {
        if (!searchProvider.enabled()) {
            throw new ConfigurationException(CustomConstants.EX_SERVICE_UNAVAILABLE);
        }
        Heatmap heatmap = new Heatmap();

        ObjectNode result =  JsonUtil.emptyObjectNode();
        ArrayNode resultArray = JsonUtil.emptyArrayNode();
        result.set("entries", resultArray);

        Bounds bounds = getMapBounds(basicCriteria, mapScale);
        for (long x = bounds.xMin; x < bounds.xMax; x = x + resolution) {
            Map<String, SearchCriteria> criteriaMap = new HashMap<>();
            for (long y = bounds.yMin; y < bounds.yMax; y = y + resolution) {
                criteriaMap.put(Long.toString(y), new LongRangeSearchCriteria(PLAYER_POS_Y,mapScale.toGameScaleY(y),mapScale.toGameScaleY(y + PIXELS_PER_CALL) -1, false));
            }
            SearchQuery searchQuery = new SearchQuery(0);
            List<SearchCriteria> searchCriteriaList = new ArrayList<>(basicCriteria);
            searchCriteriaList.add(new LongRangeSearchCriteria(PLAYER_POS_X, mapScale.toGameScaleX(x),mapScale.toGameScaleX(x + PIXELS_PER_CALL) -1, false));
            searchQuery.setFilters(searchCriteriaList);
            searchQuery.setAggregations(List.of(new CriteriaAggregation("values", criteriaMap, COUNT_AGGREGATION)));
            SearchResult searchResult = searchProvider.fetch("r2ts-match-event",searchQuery);
            for (Map.Entry<String, Object> entry: ((CriteriaAggregationResult) searchResult.getAggregations().get("values")).getCriteriaResult().entrySet()) {
                long count = parseLongFromDouble(entry.getValue());
                if (count != 0) {
                    ObjectNode node = JsonUtil.emptyObjectNode();
                    node.put("x", mapScale.toMinimapFormatX(mapScale.toGameScaleX(x)));
                    node.put("y", mapScale.toMinimapFormatY(mapScale.toGameScaleY(Long.parseLong(entry.getKey()))));
                    node.put(COUNT, count);
                    resultArray.add(node);
                    if (heatmap.getHighestCount() < count) {
                        heatmap.setHighestCount(count);
                    }
                }
            }
        }
        heatmap.setData(result);

        return heatmap;
    }

    protected Bounds getMapBounds(List<SearchCriteria> searchCriteriaList, MapScale mapScale) {
        /*
        SearchQuery searchQuery = new SearchQuery(0);
        searchQuery.setFilters(searchCriteriaList);
        searchQuery.setAggregations(List.of(
                        new SimpleFieldAggregation("xMin",PLAYER_POS_X, SimpleFieldAggregation.Type.MIN),
                        new SimpleFieldAggregation("xMax",PLAYER_POS_X, SimpleFieldAggregation.Type.MAX),
                        new SimpleFieldAggregation("yMin",PLAYER_POS_Y, SimpleFieldAggregation.Type.MIN),
                        new SimpleFieldAggregation("yMax",PLAYER_POS_Y, SimpleFieldAggregation.Type.MAX)));

        SearchResult searchResult = searchRepository.fetch("r2ts-match-event",searchQuery);
        Bounds bounds = new Bounds(
                mapScale.toMinimapScaleX(getCountFromResult(searchResult,"xMin")),
                mapScale.toMinimapScaleX(getCountFromResult(searchResult,"xMax")),
                mapScale.toMinimapScaleY(getCountFromResult(searchResult,"yMin")),
                mapScale.toMinimapScaleY(getCountFromResult(searchResult,"yMax"))
        );
         */
        Bounds bounds = new Bounds(0,1024,0,1024);
        LOGGER.debug("Bounds for current heatmap calculations [{}]", bounds);
        return bounds;
        //FIXME Currently disabled due to the xMin being higher than it should be
    }

    protected long getCountFromResult(SearchResult searchResult, String name) {
        return parseLongFromDouble(((SimpleAggregationResult) searchResult.getAggregations().get(name)).getValue());
    }

    protected long parseLongFromDouble(Object value) {
        return Math.round((double) value);
    }

    protected record Bounds(long xMin, long xMax, long yMin, long yMax) {
        @Override
        public String toString() {
            return JsonUtil.toJson(this);
        }
    }
}
