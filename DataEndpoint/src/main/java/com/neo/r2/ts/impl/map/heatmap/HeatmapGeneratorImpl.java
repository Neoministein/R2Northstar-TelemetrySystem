package com.neo.r2.ts.impl.map.heatmap;

import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.neo.r2.ts.impl.map.scaling.GameMap;
import com.neo.r2.ts.impl.map.scaling.MapScale;
import com.neo.r2.ts.impl.map.scaling.MapScalingService;
import com.neo.r2.ts.impl.match.MatchService;
import com.neo.r2.ts.impl.persistence.entity.Heatmap;
import com.neo.r2.ts.impl.persistence.entity.HeatmapType;
import com.neo.r2.ts.impl.persistence.entity.Match;
import com.neo.r2.ts.impl.persistence.searchable.MatchEventSearchable;
import com.neo.util.common.impl.StopWatch;
import com.neo.util.common.impl.exception.InternalJsonException;
import com.neo.util.common.impl.exception.InternalLogicException;
import com.neo.util.common.impl.json.JsonUtil;
import com.neo.util.framework.api.persistence.aggregation.*;
import com.neo.util.framework.api.persistence.criteria.CombinedSearchCriteria;
import com.neo.util.framework.api.persistence.criteria.ExplicitSearchCriteria;
import com.neo.util.framework.api.persistence.criteria.LongRangeSearchCriteria;
import com.neo.util.framework.api.persistence.criteria.SearchCriteria;
import com.neo.util.framework.api.persistence.entity.EntityRepository;
import com.neo.util.framework.api.persistence.search.SearchQuery;
import com.neo.util.framework.api.persistence.search.SearchRepository;
import com.neo.util.framework.api.persistence.search.SearchResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import jakarta.transaction.RollbackException;
import java.util.*;

@ApplicationScoped
public class HeatmapGeneratorImpl {

    private static final Logger LOGGER = LoggerFactory.getLogger(HeatmapGeneratorImpl.class);

    protected static final String COUNT = "count";
    protected static final String PLAYER_POS_X = "entity.position.x";
    protected static final String PLAYER_POS_Y = "entity.position.y";

    protected static final int PIXELS_PER_CALL = 4;

    protected static final SimpleFieldAggregation COUNT_AGGREGATION = new SimpleFieldAggregation(COUNT, MatchEventSearchable.F_MATCH_ID, SimpleFieldAggregation.Type.COUNT);

    @Inject
    protected EntityRepository repository;

    @Inject
    protected SearchRepository searchRepository;

    @Inject
    protected MapScalingService mapScalingService;

    @Inject
    protected MatchService matchService;

    public Heatmap calculateMap(String map) {
        Heatmap heatmap = calculate(
                mapScalingService.getMap(map).orElseThrow(() -> new InternalLogicException("Map not supported")),
                List.of(new ExplicitSearchCriteria("map", map)),
                PIXELS_PER_CALL);
        heatmap.setType(HeatmapType.FULL_MAP_AGGREGATION);
        heatmap.setDescription("This is an autogenerated heatmap for the map " + map);
        try {
            repository.create(heatmap);
        } catch (RollbackException ex) {
            throw new InternalLogicException("Cannot save heatmap rollback exception", ex);
        }

        return heatmap;
    }

    public Heatmap calculateMatch(String matchId, HeatmapType heatmapType) {
        Optional<Match> optionalMatch = matchService.getMatch(matchId);
        if (optionalMatch.isEmpty()) {
            throw new InternalLogicException("Unknown match id");
        }
        Match match = optionalMatch.get();

        List<SearchCriteria> searchCriteriaList = new ArrayList<>();
        switch (heatmapType) {
            case PLAYER_POSITION:
                searchCriteriaList.add(new ExplicitSearchCriteria(MatchEventSearchable.F_MATCH_ID, match.getId().toString()));
                break;
            case FULL_MAP_AGGREGATION:
            case CUSTOM:
            default:
                throw new InternalLogicException("Unsupported heatmap type");
        }

        Heatmap heatmap = calculate(
                mapScalingService.getMap(match.getMap()).orElseThrow(() -> new InternalLogicException("Map not supported")),
                searchCriteriaList,
                PIXELS_PER_CALL);
        heatmap.setType(heatmapType);
        heatmap.setDescription("This is an autogenerated heatmap for the match " + matchId);

        matchService.addHeatmap(match, heatmap);
        return heatmap;
    }

    public Heatmap calculate(GameMap gameMap, List<SearchCriteria> searchCriteria, int resolution) {
        if (searchRepository.enabled()) {
            Heatmap heatmap = new Heatmap();
            heatmap.setType(HeatmapType.CUSTOM);
            heatmap.setHighestCount(0L);
            heatmap.setMap(gameMap.name());

            MapScale mapScale = gameMap.scale();
            ObjectNode result =  JsonUtil.emptyObjectNode();
            ArrayNode resultArray = JsonUtil.emptyArrayNode();
            result.set("entries", resultArray);

            Bounds bounds = getMapBounds(searchCriteria, mapScale);
            for (long x = bounds.xMin; x < bounds.xMax; x = x + resolution) {
                SearchQuery searchQuery = new SearchQuery(0);
                searchQuery.setFilters(searchCriteria);
                Map<String, SearchCriteria> criteriaMap = new HashMap<>();
                searchQuery.setAggregations(List.of(COUNT_AGGREGATION));
                for (long y = bounds.yMin; y < bounds.yMax; y = y + resolution) {
                    CombinedSearchCriteria criteria = new CombinedSearchCriteria(
                            new LongRangeSearchCriteria(PLAYER_POS_X, mapScale.toGameScaleX(x),mapScale.toGameScaleX(x + PIXELS_PER_CALL) -1, false),
                            new LongRangeSearchCriteria(PLAYER_POS_Y,mapScale.toGameScaleY(y),mapScale.toGameScaleY(y + PIXELS_PER_CALL) -1, false)
                    );
                    criteriaMap.put(Long.toString(y), criteria);
                }
                searchQuery.setAggregations(List.of(new CriteriaAggregation("test", criteriaMap, COUNT_AGGREGATION)));
                SearchResult searchResult = searchRepository.fetch("r2ts-match-event",searchQuery);
                for (Map.Entry<String, Object> entry: ((CriteriaAggregationResult) searchResult.getAggregations().get("test")).getCriteriaResult().entrySet()) {
                    long count = parseLongFromDouble(entry.getValue());
                    if (count != 0) {
                        ObjectNode node = JsonUtil.emptyObjectNode();
                        node.put("x", mapScale.toMinimapFormatX(mapScale.toGameScaleX(x)));
                        node.put("y", mapScale.toMinimapFormatY(mapScale.toGameScaleY(Long.parseLong(entry.getKey()))));
                        node.put(COUNT, count);
                        resultArray.add(node);
                        if (heatmap.getHighestCount() < count) {
                            heatmap.setHighestCount(count);
                        }
                    }
                }
            }
            heatmap.setData(result);
            return heatmap;

        }
        throw new InternalJsonException("A");
    }

    protected Bounds getMapBounds(List<SearchCriteria> searchCriteriaList, MapScale mapScale) {
        SearchQuery searchQuery = new SearchQuery(0);
        searchQuery.setFilters(searchCriteriaList);
        searchQuery.setAggregations(List.of(
                        new SimpleFieldAggregation("xMin",PLAYER_POS_X, SimpleFieldAggregation.Type.MIN),
                        new SimpleFieldAggregation("xMax",PLAYER_POS_X, SimpleFieldAggregation.Type.MAX),
                        new SimpleFieldAggregation("yMin",PLAYER_POS_Y, SimpleFieldAggregation.Type.MIN),
                        new SimpleFieldAggregation("yMax",PLAYER_POS_Y, SimpleFieldAggregation.Type.MAX)));

        SearchResult searchResult = searchRepository.fetch("r2ts-match-event",searchQuery);
        return new Bounds(
                mapScale.toMinimapScaleX(getCountFromResult(searchResult,"xMin")),
                mapScale.toMinimapScaleX(getCountFromResult(searchResult,"xMax")),
                mapScale.toMinimapScaleY(getCountFromResult(searchResult,"yMin")),
                mapScale.toMinimapScaleY(getCountFromResult(searchResult,"yMax"))
        );
    }

    protected long getCountFromResult(SearchResult searchResult, String name) {
        return parseLongFromDouble(((SimpleAggregationResult) searchResult.getAggregations().get(name)).getValue());
    }

    protected long parseLongFromDouble(Object value) {
        return Math.round((double) value);
    }

    protected record Bounds(long xMin, long xMax, long yMin, long yMax){}
}
