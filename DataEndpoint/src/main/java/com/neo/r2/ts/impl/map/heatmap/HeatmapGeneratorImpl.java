package com.neo.r2.ts.impl.map.heatmap;

import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.neo.r2.ts.impl.map.scaling.GameMap;
import com.neo.r2.ts.impl.map.scaling.MapScale;
import com.neo.r2.ts.impl.map.scaling.MapScalingService;
import com.neo.r2.ts.impl.match.MatchService;
import com.neo.r2.ts.impl.persistence.entity.Heatmap;
import com.neo.r2.ts.impl.persistence.entity.HeatmapType;
import com.neo.r2.ts.impl.persistence.entity.Match;
import com.neo.r2.ts.impl.persistence.searchable.MatchEvent;
import com.neo.r2.ts.impl.persistence.searchable.MatchEventSearchable;
import com.neo.util.common.impl.exception.InternalJsonException;
import com.neo.util.common.impl.exception.InternalLogicException;
import com.neo.util.common.impl.json.JsonUtil;
import com.neo.util.framework.api.persistence.aggregation.*;
import com.neo.util.framework.api.persistence.criteria.ExplicitSearchCriteria;
import com.neo.util.framework.api.persistence.criteria.LongRangeSearchCriteria;
import com.neo.util.framework.api.persistence.criteria.SearchCriteria;
import com.neo.util.framework.api.persistence.entity.EntityRepository;
import com.neo.util.framework.api.persistence.search.SearchQuery;
import com.neo.util.framework.api.persistence.search.SearchRepository;
import com.neo.util.framework.api.persistence.search.SearchResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import jakarta.transaction.RollbackException;
import java.util.*;

@ApplicationScoped
public class HeatmapGeneratorImpl {

    private static final Logger LOGGER = LoggerFactory.getLogger(HeatmapGeneratorImpl.class);

    protected static final String COUNT = "count";
    protected static final String PLAYER_POS_X = "entity.position.x";
    protected static final String PLAYER_POS_Y = "entity.position.y";

    protected static final int PIXELS_PER_CALL = 4;

    protected static final SimpleFieldAggregation COUNT_AGGREGATION = new SimpleFieldAggregation(COUNT, MatchEventSearchable.F_MATCH_ID, SimpleFieldAggregation.Type.COUNT);

    @Inject
    protected EntityRepository repository;

    @Inject
    protected SearchRepository searchRepository;

    @Inject
    protected MapScalingService mapScalingService;

    @Inject
    protected MatchService matchService;

    public Heatmap calculateMap(String map) {
        GameMap gameMap = mapScalingService.getMap(map).orElseThrow(() -> new InternalLogicException("Map not supported"));

        Heatmap heatmap = new Heatmap();
        heatmap.setMap(gameMap.name());
        heatmap.setType(HeatmapType.FULL_MAP_AGGREGATION);
        heatmap.setDescription("This is an autogenerated heatmap for the map " + map);
        heatmap.setHighestCount(0L);
        calculate(heatmap, gameMap.scale(),
                List.of(
                        new ExplicitSearchCriteria("map", map),
                        new ExplicitSearchCriteria("eventType", MatchEvent.PLAYER_POSITION.fieldName)),
                PIXELS_PER_CALL);
        try {
            repository.create(heatmap);
        } catch (RollbackException ex) {
            throw new InternalLogicException("Cannot save heatmap rollback exception", ex);
        }

        return heatmap;
    }

    public Heatmap calculateMatch(String matchId, HeatmapType heatmapType) {
        Optional<Match> optionalMatch = matchService.getMatch(matchId);
        if (optionalMatch.isEmpty()) {
            throw new InternalLogicException("Unknown match id");
        }
        Match match = optionalMatch.get();

        List<SearchCriteria> searchCriteriaList = new ArrayList<>();
        switch (heatmapType) {
            case PLAYER_POSITION:
                searchCriteriaList.add(new ExplicitSearchCriteria(MatchEventSearchable.F_MATCH_ID, match.getId().toString()));
                searchCriteriaList.add(new ExplicitSearchCriteria("eventType", MatchEvent.PLAYER_POSITION.fieldName));
                break;
            case FULL_MAP_AGGREGATION:
            case CUSTOM:
            default:
                throw new InternalLogicException("Unsupported heatmap type");
        }
        GameMap gameMap = mapScalingService.getMap(match.getMap()).orElseThrow(() -> new InternalLogicException("Map not supported"));

        Heatmap heatmap = new Heatmap();
        heatmap.setMap(gameMap.name());
        heatmap.setType(heatmapType);
        heatmap.setHighestCount(0L);
        heatmap.setDescription("This is an autogenerated heatmap for the match " + matchId);
        calculate(
                heatmap,
                gameMap.scale(),
                searchCriteriaList,
                PIXELS_PER_CALL);

        matchService.addHeatmap(match, heatmap);
        return heatmap;
    }

    public void calculate(Heatmap heatmap, MapScale mapScale, List<SearchCriteria> basicCriteria, int resolution) {
        if (searchRepository.enabled()) {
            ObjectNode result =  JsonUtil.emptyObjectNode();
            ArrayNode resultArray = JsonUtil.emptyArrayNode();
            result.set("entries", resultArray);

            Bounds bounds = getMapBounds(basicCriteria, mapScale);
            for (long x = bounds.xMin; x < bounds.xMax; x = x + resolution) {
                Map<String, SearchCriteria> criteriaMap = new HashMap<>();
                for (long y = bounds.yMin; y < bounds.yMax; y = y + resolution) {
                    criteriaMap.put(Long.toString(y), new LongRangeSearchCriteria(PLAYER_POS_Y,mapScale.toGameScaleY(y),mapScale.toGameScaleY(y + PIXELS_PER_CALL) -1, false));
                }
                SearchQuery searchQuery = new SearchQuery(0);
                List<SearchCriteria> searchCriteriaList = new ArrayList<>(basicCriteria);
                searchCriteriaList.add(new LongRangeSearchCriteria(PLAYER_POS_X, mapScale.toGameScaleX(x),mapScale.toGameScaleX(x + PIXELS_PER_CALL) -1, false));
                searchQuery.setFilters(searchCriteriaList);
                searchQuery.setAggregations(List.of(new CriteriaAggregation("values", criteriaMap, COUNT_AGGREGATION)));
                SearchResult searchResult = searchRepository.fetch("r2ts-match-event",searchQuery);
                for (Map.Entry<String, Object> entry: ((CriteriaAggregationResult) searchResult.getAggregations().get("values")).getCriteriaResult().entrySet()) {
                    long count = parseLongFromDouble(entry.getValue());
                    if (count != 0) {
                        ObjectNode node = JsonUtil.emptyObjectNode();
                        node.put("x", mapScale.toMinimapFormatX(mapScale.toGameScaleX(x)));
                        node.put("y", mapScale.toMinimapFormatY(mapScale.toGameScaleY(Long.parseLong(entry.getKey()))));
                        node.put(COUNT, count);
                        resultArray.add(node);
                        if (heatmap.getHighestCount() < count) {
                            heatmap.setHighestCount(count);
                        }
                    }
                }
            }
            heatmap.setData(result);
        }
    }

    protected Bounds getMapBounds(List<SearchCriteria> searchCriteriaList, MapScale mapScale) {
        /*
        SearchQuery searchQuery = new SearchQuery(0);
        searchQuery.setFilters(searchCriteriaList);
        searchQuery.setAggregations(List.of(
                        new SimpleFieldAggregation("xMin",PLAYER_POS_X, SimpleFieldAggregation.Type.MIN),
                        new SimpleFieldAggregation("xMax",PLAYER_POS_X, SimpleFieldAggregation.Type.MAX),
                        new SimpleFieldAggregation("yMin",PLAYER_POS_Y, SimpleFieldAggregation.Type.MIN),
                        new SimpleFieldAggregation("yMax",PLAYER_POS_Y, SimpleFieldAggregation.Type.MAX)));

        SearchResult searchResult = searchRepository.fetch("r2ts-match-event",searchQuery);
        Bounds bounds = new Bounds(
                mapScale.toMinimapScaleX(getCountFromResult(searchResult,"xMin")),
                mapScale.toMinimapScaleX(getCountFromResult(searchResult,"xMax")),
                mapScale.toMinimapScaleY(getCountFromResult(searchResult,"yMin")),
                mapScale.toMinimapScaleY(getCountFromResult(searchResult,"yMax"))
        );
         */
        Bounds bounds = new Bounds(0,1024,0,1024);
        LOGGER.debug("Bounds for current heatmap calculations [{}]", bounds);
        return bounds;
        //FIXME Currently disabled due to the xMin being higher than it should be
    }

    protected long getCountFromResult(SearchResult searchResult, String name) {
        return parseLongFromDouble(((SimpleAggregationResult) searchResult.getAggregations().get(name)).getValue());
    }

    protected long parseLongFromDouble(Object value) {
        return Math.round((double) value);
    }

    protected record Bounds(long xMin, long xMax, long yMin, long yMax) {
        @Override
        public String toString() {
            return JsonUtil.toJson(this);
        }
    }
}
